<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydfnworks.dfnGen.well_package.wells &mdash; dfnWorks 2.9.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index_docs.html" class="icon icon-home">
            dfnWorks
          </a>
              <div class="version">
                2.9.1 LANL, Docs: LA-UR-17-22216, Software: LA-CC-17-027
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro.html">Welcome To dfnWorks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../applications.html">Example Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../setup.html">Setup and Running dfnWorks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnworks.html">pydfnworks: the dfnWorks python package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnGen.html">pydfnworks: dfnGen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnFlow.html">pydfnworks: dfnFlow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnTrans.html">pydfnworks: dfnTrans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnGraph.html">pydfnworks: dfnGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pydfnWorks-well.html">pydfnworks: Well Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dfngen.html">dfnGen - C++ Generation Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dfnflow.html">dfnFlow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dfntrans.html">dfnTrans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../output.html">File Descriptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">dfnWorks Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery.html">dfnWorks Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_intro.html">dfnWorks Introduction and Beginner Tutorial</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index_docs.html">dfnWorks</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index_docs.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pydfnworks.dfnGen.well_package.wells</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydfnworks.dfnGen.well_package.wells</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="kn">from</span> <span class="nn">pydfnworks.dfnGen.meshing.mesh_dfn</span> <span class="kn">import</span> <span class="n">mesh_dfn_helper</span> <span class="k">as</span> <span class="n">mh</span>
<span class="kn">from</span> <span class="nn">pydfnworks.general.logging</span> <span class="kn">import</span> <span class="n">local_print_log</span>

<div class="viewcode-block" id="tag_well_in_mesh"><a class="viewcode-back" href="../../../../pydfnWorks-well.html#pydfnworks.dfnGen.well_package.wells.tag_well_in_mesh">[docs]</a><span class="k">def</span> <span class="nf">tag_well_in_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wells</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Identifies nodes in a DFN for nodes the intersect a well with radius r [m]\n</span>
<span class="sd">    1. Well coordinates in well[&quot;filename&quot;] are converted to a polyline that are written into &quot;well_{well[&#39;name&#39;]}_line.inp&quot;\n</span>
<span class="sd">    2. Well is expanded to a volume with radius well[&quot;r&quot;] and written into the avs file well_{well[&quot;name&quot;]}_volume.inp\n</span>
<span class="sd">    3. Nodes in the DFN that intersect with the well are written into the zone file well_{well[&quot;name&quot;]}.zone\n</span>
<span class="sd">    4. If using PFLOTRAN, then an ex file is created from the well zone file\n</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>
<span class="sd">        </span>
<span class="sd">        well: Dictionary</span>
<span class="sd">            Dictionary of information about the well that contains the following attributes</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates with the following format</span>
<span class="sd">                x0 y0 z0\n</span>
<span class="sd">                x1 y1 z1\n</span>
<span class="sd">                ...\n</span>
<span class="sd">                xn yn zn\n</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        Wells can be a list of well dictionaries</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">wells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;--&gt; Identifying nodes in the DFN intersecting with a vertical well named </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 1) convert well into polyline AVS if it doesn&#39;t exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp&quot;</span><span class="p">):</span>
            <span class="n">convert_well_to_polyline_avs</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

        <span class="c1"># 2) expand the polyline of the well into a volume with radius r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand_well</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

        <span class="c1"># 3) find the nodes in the well that corresponds / intersect the well</span>
        <span class="n">get_well_zone</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp_file</span><span class="p">)</span>

        <span class="c1"># 4) convert the zone file to ex files for PFLTORAN</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_solver</span> <span class="o">==</span> <span class="s2">&quot;PFLOTRAN&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zone2ex</span><span class="p">(</span><span class="n">zone_file</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="n">face</span><span class="o">=</span><span class="s1">&#39;well&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_solver</span> <span class="o">==</span> <span class="s2">&quot;FEHM&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Well nodes are in well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Well creation for </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> complete&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">wells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--&gt; Identifying nodes in the DFN intersecting with a vertical well named </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

            <span class="c1"># 1) convert well into polyline AVS if it doesn&#39;t exist</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp&quot;</span><span class="p">):</span>
                <span class="n">convert_well_to_polyline_avs</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

            <span class="c1"># 2) expand the polyline of the well into a volume with radius r</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expand_well</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

            <span class="c1"># 3) find the nodes in the well that corresponds / intersect the well</span>
            <span class="n">get_well_zone</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp_file</span><span class="p">)</span>

            <span class="c1"># 4) convert the zone file to ex files for PFLTORAN</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_solver</span> <span class="o">==</span> <span class="s2">&quot;PFLOTRAN&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zone2ex</span><span class="p">(</span><span class="n">zone_file</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span>
                             <span class="n">face</span><span class="o">=</span><span class="s1">&#39;well&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_solver</span> <span class="o">==</span> <span class="s2">&quot;FEHM&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Well nodes are in well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Well creation for </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> complete</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">convert_well_to_polyline_avs</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;  Identifies converts well coordinates into a polyline avs file. Distance between </span>
<span class="sd">    point on the polyline are h/2 apart. Polyline is written into &quot;well_{well[&#39;name&#39;]}_line.inp&quot;</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        well: dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>
<span class="sd">                </span>
<span class="sd">        h : float</span>
<span class="sd">            h parameter for meshing. </span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        If flow solver is set to PFLOTRAN, the zone file dumped by LaGriT will be converted to </span>
<span class="sd">        an ex file. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Interpolating well coordinates into a polyline&quot;</span><span class="p">)</span>


    <span class="c1"># read in well coordinates</span>
    <span class="n">local_print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well filename </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

    <span class="c1"># Linear interpolation of well into a polyline</span>
    <span class="n">new_pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">new_idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
            <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">new_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># discretized to less than h</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">radius</span><span class="p">))</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">m</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">m</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">interp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pts</span><span class="p">[</span><span class="n">new_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span>
                <span class="n">interp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pts</span><span class="p">[</span><span class="n">new_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span>
                <span class="n">interp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pts</span><span class="p">[</span><span class="n">new_idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dz</span>
                <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">interp</span>
                <span class="n">new_idx</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Interpolating well coordinates into a polyline: Complete&quot;</span><span class="p">)</span>
    <span class="c1"># Write interpolated polyline into an AVS file</span>
    <span class="n">avs_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp&quot;</span>
    <span class="n">local_print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Writing polyline into avs file : </span><span class="si">{</span><span class="n">avs_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">num_pts</span> <span class="o">=</span> <span class="n">new_idx</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">pt_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_pts</span><span class="p">))</span>

    <span class="n">num_elem</span> <span class="o">=</span> <span class="n">new_idx</span>
    <span class="n">elem_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_elem</span><span class="p">))</span>

    <span class="n">favs</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">avs_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">favs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_pts</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">num_elem</span><span class="si">}</span><span class="se">\t</span><span class="s2">0</span><span class="se">\t</span><span class="s2">0</span><span class="se">\t</span><span class="s2">0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>
        <span class="n">favs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">pt_digits</span><span class="si">}</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">new_pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">12e</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">new_pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">12e</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">new_pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">12e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_elem</span><span class="p">):</span>
        <span class="n">favs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> 1 line </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">favs</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">local_print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Writing polyline into avs file : </span><span class="si">{</span><span class="n">avs_filename</span><span class="si">}</span><span class="s2"> : Complete&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">expand_well</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">well</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;  Expands the polyline defining the well into a volume with radius r [m]. </span>
<span class="sd">    A sphere of points around each point is created and then connected.</span>
<span class="sd">    Volume is written into the avs file well_{well[&quot;name&quot;]}_volume.inp</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>

<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>
<span class="sd">                </span>
<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        Mesh of the well is written into the avs file {well[&quot;name&quot;][:-4]}.inp </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Expanding well into a volume.&quot;</span><span class="p">)</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span>

    <span class="n">convert_well_to_polyline_avs</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">angle_r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">lagrit_script</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    ## read in polyline of well</span>
<span class="s2">    read / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp / mo_line</span>
<span class="s2">    cmo / printatt / mo_line / -xyz- / minmax</span>

<span class="s2">    ## expand every point in the polyline into a discrete sphere</span>
<span class="s2">    ## with radius r</span>
<span class="s2">    cmo / create / mo_well / / / tet</span>
<span class="s2">        copypts / mo_well / mo_line </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> 0 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / -</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> 0 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 -</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 0 </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 0 -</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / 0 -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 </span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    cmo / create / mo_tmp / / / line</span>
<span class="s2">    copypts / mo_tmp / mo_line</span>
<span class="s2">    cmo / select / mo_tmp</span>
<span class="s2">    trans / 1 0 0 / 0. 0. 0. / -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span><span class="s2"> 0 -</span><span class="si">{</span><span class="n">angle_r</span><span class="si">}</span>
<span class="s2">    copypts / mo_well / mo_tmp</span>
<span class="s2">    cmo / delete / mo_tmp </span>

<span class="s2">    ## Could add more permutations, but this looks good enough right now</span>
<span class="s2">    ## JDH 9 Sept. 2020</span>

<span class="s2">    ################## DEBUG ########################### </span>
<span class="s2">    # dump / well_pts.inp / mo_well</span>
<span class="s2">    ################## DEBUG ########################### </span>

<span class="s2">    # filter out point that are too close</span>
<span class="s2">    cmo / select / mo_well</span>
<span class="s2">    filter / 1 0 0 / </span><span class="si">{</span><span class="mf">0.1</span><span class="o">*</span><span class="n">r</span><span class="si">}</span>
<span class="s2">    rmpoint / compress</span>
<span class="s2">    cmo / setatt / mo_well / imt / 1 0 0 / 1</span>

<span class="s2">    # connect the point cloud and make a volume mesh</span>
<span class="s2">    connect / delaunay</span>
<span class="s2">    resetpts / itp</span>

<span class="s2">    ################## DEBUG ########################### </span>
<span class="s2">    # dump / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">.inp / mo_well</span>
<span class="s2">    ################## DEBUG ########################### </span>

<span class="s2">    # add edge_max attribute and remove elements with big edges</span>
<span class="s2">    quality / edge_max / y</span>
<span class="s2">    eltset /big/ edgemax / gt / </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="si">}</span>
<span class="s2">    cmo / setatt / mo_well / itetclr /  eltset, get, big / 2</span>
<span class="s2">    rmmat / 2 </span>
<span class="s2">    rmpoint / compress</span>

<span class="s2">    dump / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_volume.inp / mo_well</span>

<span class="s2">    ################## DEBUG ########################### </span>
<span class="s2">    # # extract the surface of the well </span>
<span class="s2">    # # This is done to remove internal points and reduce</span>
<span class="s2">    # # the total number of elements in the mesh</span>
<span class="s2">    # # This speeds up the intersection checking later on</span>
<span class="s2">    # # I couldn&#39;t get this to work in a robust way.</span>
<span class="s2">    # # There were some weird LaGriT errors if I deleted </span>
<span class="s2">    # # mesh object.</span>
<span class="s2">    # # Works if we stop before this, but I&#39;m leaving it to </span>
<span class="s2">    # # revisit if need be. </span>
<span class="s2">    # # JDH 10/9/2020</span>

<span class="s2">    # extract / surfmesh / 1,0,0 /mo_shell / mo_well</span>
<span class="s2">    # cmo / select / mo_shell</span>
<span class="s2">    # cmo / delete / mo_well</span>

<span class="s2">    # ################## DEBUG ########################### </span>
<span class="s2">    # dump / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_shell.inp / mo_shell</span>
<span class="s2">    # ################## DEBUG ########################### </span>

<span class="s2">    # # Copy the surface of the well into a tet mesh</span>
<span class="s2">    # cmo / create / mo_well2 / / / tet</span>
<span class="s2">    # copypts / mo_well2 / mo_shell </span>
<span class="s2">    # cmo / select / mo_well2</span>
<span class="s2">    # # cmo / delete / mo_shell</span>

<span class="s2">    # # filter out point that are too close</span>
<span class="s2">    # filter / 1 0 0 / </span><span class="si">{</span><span class="mf">0.1</span><span class="o">*</span><span class="n">r</span><span class="si">}</span>
<span class="s2">    # rmpoint / compress</span>
<span class="s2">    # cmo / setatt / mo_well2 / imt / 1 0 0 / 1</span>

<span class="s2">    # # connect the point cloud and make a volume mesh</span>
<span class="s2">    # connect / delaunay</span>
<span class="s2">    # resetpts / itp</span>

<span class="s2">    # # add edge_max attribute and remove elements with big edges</span>
<span class="s2">    # quality / edge_max / y</span>
<span class="s2">    # eltset /big/ edgemax / gt / </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="si">}</span>
<span class="s2">    # cmo / setatt / mo_well2 / itetclr /  eltset, get, big / 2</span>
<span class="s2">    # rmmat / 2 </span>
<span class="s2">    # rmpoint / compress</span>

<span class="s2">    # # write out final well mesh</span>
<span class="s2">    # dump / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_volume.inp / mo_well2</span>

<span class="s2">    finish</span>

<span class="s2">    &quot;&quot;&quot;</span>
    <span class="c1"># Write LaGriT commands to file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expand_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.lgi&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lagrit_script</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Execute LaGriT</span>
    <span class="n">mh</span><span class="o">.</span><span class="n">run_lagrit_script</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expand_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.lgi&quot;</span><span class="p">,</span>
                         <span class="n">output_file</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;expand_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                         <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Expanding well complete.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_well_zone</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">inp_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identifies nodes in a DFN for nodes the intersect a well with radius r [m]</span>
<span class="sd">    First, all elements that intersect the well are identified. </span>
<span class="sd">    Second, all nodes of those elements are tagged. </span>
<span class="sd">    Third, that collection of nodes are dumped as a zone file (well_{well[&quot;name&quot;]}.zone)</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>
<span class="sd">        </span>
<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                File format:  </span>
<span class="sd">                x0 y0 z0</span>
<span class="sd">                x1 y1 z1</span>
<span class="sd">                ...</span>
<span class="sd">                xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># # if the well has not been converted to AVS, do that first</span>
    <span class="c1"># if not os.path.isfile(f&quot;well_{well[&#39;name&#39;]}_line.inp&quot;):</span>
    <span class="c1">#     convert_well_to_polyline_avs(well,h)</span>
    <span class="c1"># # if the well has not been expanded</span>
    <span class="c1"># if not os.path.isfile(f&quot;well_{well[&#39;name&#39;]}_volume.inp&quot;):</span>
    <span class="c1">#     expand_well(well)</span>

    <span class="n">lagrit_script</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2"># read in well volume</span>
<span class="s2">read / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_volume.inp / mo_well</span>

<span class="s2"># read in DFN </span>
<span class="s2">read / </span><span class="si">{</span><span class="n">inp_file</span><span class="si">}</span><span class="s2"> / mo_dfn</span>

<span class="s2"># find intersecting cells</span>
<span class="s2">cmo / select / mo_dfn</span>
<span class="s2">intersect_elements / mo_dfn / mo_well / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_inter </span>

<span class="s2">eltset / ewell / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">_inter / gt / 0</span>

<span class="s2"># dump dfn mesh with intersections tagged</span>
<span class="s2">#dump / avs / </span><span class="si">{</span><span class="n">inp_file</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">_tagged.inp / mo_dfn</span>

<span class="s2"># gather nodes of intersecting cells</span>
<span class="s2">pset / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / eltset / ewell</span>

<span class="s2"># dump nodes from intersecting cells</span>
<span class="s2">pset / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / zone / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone</span>

<span class="s2">finish</span>

<span class="s2">&quot;&quot;&quot;</span>
    <span class="c1"># Write LaGriT commands to file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;get_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_zone.lgi&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lagrit_script</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Execute LaGriT</span>
    <span class="n">mh</span><span class="o">.</span><span class="n">run_lagrit_script</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;get_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_zone.lgi&quot;</span><span class="p">,</span>
                         <span class="n">output_file</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;create_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                         <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">number_of_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">number_of_nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">local_print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; There are </span><span class="si">{</span><span class="n">number_of_nodes</span><span class="si">}</span><span class="s2"> nodes in the well zone&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Warning. The well did not intersect the DFN.&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="find_well_intersection_points"><a class="viewcode-back" href="../../../../pydfnWorks-well.html#pydfnworks.dfnGen.well_package.wells.find_well_intersection_points">[docs]</a><span class="k">def</span> <span class="nf">find_well_intersection_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wells</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Identifies points on a DFN where the well intersects the network. </span>
<span class="sd">    These points are used in meshing the network to have higher resolution  in the mesh in these points.</span>
<span class="sd">    Calls a sub-routine run_find_well_intersection_points. </span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>
<span class="sd">        </span>
<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        Wells can be a list of well dictionaries.</span>
<span class="sd">        Calls the subroutine run_find_well_intersection_points to remove redundant code.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check for reduced mesh, if it doesn&#39;t exists, make it</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Checking for reduced_mesh.inp&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s2">&quot;reduced_mesh.inp&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; reduced_mesh.inp not found. Creating it now.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_network</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; reduced_mesh.inp found. Moving on.&quot;</span><span class="p">)</span>

    <span class="c1"># if using a single well</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_find_well_intersection_points</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span>
    <span class="c1"># using a list of wells, loop over them.</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">wells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_find_well_intersection_points</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

    <span class="c1"># Run cross check</span>
    <span class="n">cross_check_pts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">run_find_well_intersection_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">well</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Runs the workflow for finding the point of intersection of the DFN with the well. </span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>

<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>
<span class="sd">        h : float</span>
<span class="sd">            Minimum h length scale in the network</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        This function was designed to minimize redundancy in the workflow. It&#39;s called</span>
<span class="sd">        within find_well_intersection_points()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Working on well </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># 1) convert well into polyline AVS</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp&quot;</span><span class="p">):</span>
        <span class="n">convert_well_to_polyline_avs</span><span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># run LaGriT scripts to dump information</span>
    <span class="n">find_segments</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">well_point_of_intersection</span><span class="p">(</span><span class="n">well</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_segments</span><span class="p">(</span><span class="n">well</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; LaGriT script to identify the points of intersection between the DFN and the well.</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        points of intersection are written into the avs file well_{well[&#39;name&#39;]}_intersect.inp</span>
<span class="sd">        </span>
<span class="sd">        OUTPUT: well_segments_intersect.inp is a subset of the well line segments that intersect fractures.</span>
<span class="sd">                 The segments are tagged so itetclr and imt are set to the value of the fracture they intersect.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lagrit_script</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#</span>
<span class="s2"># OUTPUT: intersected_fracture.list tells you the list of fractures intersected by the well.</span>
<span class="s2"># OUTPUT: well_segments_intersect.inp is a subset of the well line segments that intersect fractures.</span>
<span class="s2">#         The segments are tagged so itetclr and imt are set to the value of the fracture they intersect.</span>
<span class="s2">#</span>
<span class="s2">define / INPUT_DFN  / reduced_mesh.inp</span>
<span class="s2">define / INPUT_WELL / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_line.inp</span>
<span class="s2">define / OUTPUT_WELL_SEGMENTS / well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_intersect.inp</span>
<span class="s2"># define / OUTPUT_FRACTURE_LIST / </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_fracture.list</span>
<span class="s2">#</span>
<span class="s2">read / avs / INPUT_DFN  / mo_tri</span>
<span class="s2">read / avs / INPUT_WELL / mo_line</span>
<span class="s2">#</span>
<span class="s2"># Find the triangles of the DFN mesh that intersect the well lines.</span>
<span class="s2"># Get rid of all the non-intersecting triangles.</span>
<span class="s2">#</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>
<span class="s2">#</span>
<span class="s2"># dump / avs / reduced_reduced_mesh.inp / mo_tri</span>
<span class="s2">cmo / addatt / mo_tri / id_fracture / vint / scalar / nelements</span>
<span class="s2">cmo / copyatt / mo_tri / mo_tri / id_fracture / itetclr</span>
<span class="s2"># dump / avs / OUTPUT_FRACTURE_LIST / mo_tri / 0 0 0 1</span>
<span class="s2">#</span>
<span class="s2"># Find the segments of the well (line object) that intersect the fracture planes (triangles)</span>
<span class="s2">#</span>
<span class="s2">intersect_elements / mo_line / mo_tri / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_line / if_intersect</span>
<span class="s2"># BEGIN DEBUG</span>
<span class="s2"># dump / avs / OUTPUT_WELL_SEGMENTS / mo_line</span>
<span class="s2"># END DEBUG</span>
<span class="s2">#</span>
<span class="s2"># Reduce the size of the triangles so interpolation works.</span>
<span class="s2">#</span>
<span class="s2">cmo / select / mo_tri</span>
<span class="s2"># Refine 2**7  128</span>
<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2">refine2d</span>
<span class="s2">intersect_elements / mo_tri / mo_line / if_intersect</span>
<span class="s2">eltset / e_not_intersect / if_intersect / eq / 0</span>
<span class="s2">rmpoint / element / eltset get e_not_intersect</span>
<span class="s2">rmpoint / compress</span>
<span class="s2">cmo / DELATT / mo_tri / if_intersect</span>

<span class="s2"># BEGIN DEBUG</span>
<span class="s2"># dump / avs / tmp_refine.inp / mo_tri</span>
<span class="s2"># END DEBUG</span>

<span class="s2">interpolate / voronoi / mo_line itetclr / 1 0 0 / mo_tri imt</span>
<span class="s2">interpolate / voronoi / mo_line imt     / 1 0 0 / mo_tri imt</span>

<span class="s2">cmo / modatt / mo_line / itp / ioflag / l</span>
<span class="s2">cmo / modatt / mo_line / icr / ioflag / l</span>
<span class="s2">cmo / modatt / mo_line / isn / ioflag / l</span>

<span class="s2">dump / avs / OUTPUT_WELL_SEGMENTS / mo_line</span>

<span class="s2">finish</span>


<span class="s2">&quot;&quot;&quot;</span>
    <span class="c1"># Write LaGriT commands to file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;find_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_segment.lgi&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lagrit_script</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Execute LaGriT</span>
    <span class="n">mh</span><span class="o">.</span><span class="n">run_lagrit_script</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;find_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_segment.lgi&quot;</span><span class="p">,</span>
                         <span class="n">output_file</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;find_well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_segment&quot;</span><span class="p">,</span>
                         <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">well_point_of_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">well</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Takes the well points found using find_segments and projects the points onto the fracture plane. These points are written into well_points.dat file. During meshing, these points are read in and a higher resolution mesh is created near by them. well_points.dat has the format</span>

<span class="sd">    fracture_id x y z</span>
<span class="sd">    ...</span>

<span class="sd">    for every intersection point. </span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>

<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Finding well points on DFN for </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># create file to keep well points if it doesn&#39;t exist. Otherwise set to append.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s2">&quot;well_points.dat&quot;</span><span class="p">):</span>
        <span class="n">fwell</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;well_points.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fwell</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;fracture_id x y z</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fwell</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;well_points.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>

    <span class="n">well_line_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_intersect.inp&quot;</span>

    <span class="n">pts</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">fracture_list</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">well_line_file</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fracture_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--&gt; Warning. The well </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> did not intersect the DFN!!!</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_points</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>  <span class="c1"># Parameterize the line center of the well</span>
        <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">l0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt1&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt1&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
        <span class="n">l0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt1&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">l1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt2&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">l1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt2&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
        <span class="n">l1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;pt2&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l0</span>

        <span class="n">fracture_id</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="s2">&quot;frac&quot;</span><span class="p">]</span>
        <span class="c1"># get the plane on which the fracture lies</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vectors</span><span class="p">[</span><span class="n">fracture_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">fracture_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># p0 = get_center(fracture_id)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># find the point of intersection between the well line and the plane</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">p0</span> <span class="o">-</span> <span class="n">l0</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">l0</span> <span class="o">+</span> <span class="n">l</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">rotate_point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="n">fwell</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fracture_id</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fwell</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">cross_check_pts</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Sometimes multiple points of intersection are identified on the same fracture. This can occur if the discretized well has points close to the fracture plane. This function walks through well_points.dat and removes duplicate points that are within h of one another and on the same fracture plane. </span>


<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        h : float</span>
<span class="sd">            Minimum length scale in the network.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--&gt; Cross Checking well points&quot;</span><span class="p">)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s2">&quot;well_points.dat&quot;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num_pts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

    <span class="c1"># Walk through well points and see if they are too close together,</span>
    <span class="c1"># This can happen due to machine precision in LaGriT.</span>
    <span class="c1"># We only keep 1 point per fracture per well.</span>
    <span class="n">remove_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>
        <span class="n">fracture_number</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_pts</span><span class="p">):</span>
            <span class="c1"># Check if points are on the same fracture to reduce number of distance checks</span>
            <span class="k">if</span> <span class="n">fracture_number</span> <span class="o">==</span> <span class="n">pts</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="c1"># if the points are closure that h/2, mark one to be removed.</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">remove_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="c1"># Find the id of those points to keep</span>
    <span class="n">keep_pt_indes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">remove_idx</span><span class="p">))</span>
    <span class="c1"># keep only those points</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">keep_pt_indes</span><span class="p">]</span>
    <span class="n">num_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="c1"># write to file</span>
    <span class="c1"># os.remove(&quot;well_points.dat&quot;)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;well_points.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fwell</span><span class="p">:</span>
        <span class="n">fwell</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;fracture_id x y z</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>
            <span class="n">fwell</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Cross Checking Complete&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="n">well_line_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Parses well_line_file (avs) to get point information, element information, and list of fractures that intersect the well.</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        well_line_file : string</span>
<span class="sd">            filename of well_line_file written by find_segments()</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        pts : list</span>
<span class="sd">            list of dictionaries of intersection points. dictionary contains fracture id and x,y,z coordinates</span>
<span class="sd">        </span>
<span class="sd">        elems: list of dictionaries</span>
<span class="sd">            Information about elements of the discretized well that intersect the DFN</span>
<span class="sd">        </span>
<span class="sd">        fracture_list : list</span>
<span class="sd">            list of fractures that the well intersects</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">well_line_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">num_elem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_elem</span><span class="p">):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pt1&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;pt2&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;frac&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;pt1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;pt2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;frac&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="c1"># get fracture list</span>
    <span class="n">fracture_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_elem</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;frac&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fracture_list</span><span class="p">:</span>
            <span class="n">fracture_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;frac&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">pts</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">fracture_list</span>


<span class="c1"># def get_normal(self, fracture_id):</span>
<span class="c1">#     &quot;&quot;&quot; Returns Normal vector of a fracture</span>

<span class="c1">#     Parameters    </span>
<span class="c1">#     -----------</span>
<span class="c1">#         fracture_id : int</span>
<span class="c1">#             fracture number</span>

<span class="c1">#     Returns</span>
<span class="c1">#     --------</span>
<span class="c1">#         normal : numpy array</span>
<span class="c1">#             normal vector of a fracture</span>

<span class="c1">#     Notes</span>
<span class="c1">#     --------</span>
<span class="c1">#         None</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     normals = self.normal_vectors #np.genfromtxt(&quot;normal_vectors.dat&quot;)</span>
<span class="c1">#     return normals[fracture_id - 1, :]</span>


<span class="c1"># def get_center(fracture_id):</span>
<span class="c1">#     &quot;&quot;&quot; Returns center of a fracture</span>

<span class="c1">#     Parameters    </span>
<span class="c1">#     -----------</span>
<span class="c1">#         fracture_id : int</span>
<span class="c1">#             fracture number</span>

<span class="c1">#     Returns</span>
<span class="c1">#     --------</span>
<span class="c1">#         points : numpy array</span>
<span class="c1">#             x,y,z coordinates of a fracture</span>

<span class="c1">#     Notes</span>
<span class="c1">#     --------</span>
<span class="c1">#         None</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     with open(&#39;translations.dat&#39;) as old, open(&#39;points.dat&#39;, &#39;w&#39;) as new:</span>
<span class="c1">#         old.readline()</span>
<span class="c1">#         for line in old:</span>
<span class="c1">#             if not &#39;R&#39; in line:</span>
<span class="c1">#                 new.write(line)</span>
<span class="c1">#     points = np.genfromtxt(&#39;points.dat&#39;, skip_header=0, delimiter=&#39; &#39;)</span>
<span class="c1">#     return points[fracture_id - 1, :]</span>


<span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">normalA</span><span class="p">,</span> <span class="n">normalB</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create a Rotation matrix to transform normal vector A to normal vector B</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        normalA : numpy array</span>
<span class="sd">            normal vector</span>
<span class="sd">        </span>
<span class="sd">        normalB : numpy array</span>
<span class="sd">            normal vector</span>
<span class="sd">              </span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        R : numpy array</span>
<span class="sd">            Rotation matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if normals are the same.</span>
    <span class="n">comparison</span> <span class="o">=</span> <span class="n">normalA</span> <span class="o">==</span> <span class="n">normalB</span>
    <span class="n">equal_arrays</span> <span class="o">=</span> <span class="n">comparison</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c1"># If they are equal, Return the Identity Matrix</span>
    <span class="k">if</span> <span class="n">equal_arrays</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># If they are not equal, construct and return a Rotation Matrix</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">xProd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normalA</span><span class="p">,</span> <span class="n">normalB</span><span class="p">)</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xProd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">xProd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normalA</span><span class="p">,</span> <span class="n">normalB</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">xProd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xProd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">xProd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">xProd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">xProd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sin</span> <span class="o">*</span> <span class="n">sin</span><span class="p">)</span>
        <span class="n">vSquared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">vSquared</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="n">scalar</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">vSquared</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">R</span>


<span class="k">def</span> <span class="nf">rotate_point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Apply Rotation matrix R to the point p</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        p : numpy array</span>
<span class="sd">            point in 3D space</span>
<span class="sd">        </span>
<span class="sd">        R : numpy array</span>
<span class="sd">            Rotation matrix</span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        v : numpy array</span>
<span class="sd">            The point p with the rotation matrix applied</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">v</span>


<div class="viewcode-block" id="cleanup_wells"><a class="viewcode-back" href="../../../../pydfnWorks-well.html#pydfnworks.dfnGen.well_package.wells.cleanup_wells">[docs]</a><span class="k">def</span> <span class="nf">cleanup_wells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wells</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Moves working files created while making wells into well_data directory</span>

<span class="sd">    Parameters    </span>
<span class="sd">    -----------</span>
<span class="sd">        self : object</span>
<span class="sd">            DFN Class</span>
<span class="sd">        </span>
<span class="sd">        well:</span>
<span class="sd">            dictionary of information about the well. Contains the following:</span>

<span class="sd">            well[&quot;name&quot;] : string </span>
<span class="sd">                name of the well</span>

<span class="sd">            well[&quot;filename&quot;] : string </span>
<span class="sd">                filename of the well coordinates. &quot;well_coords.dat&quot; for example.</span>
<span class="sd">                 Format is :</span>
<span class="sd">                 x0 y0 z0</span>
<span class="sd">                 x1 y1 z1</span>
<span class="sd">                 ...</span>
<span class="sd">                 xn yn zn</span>

<span class="sd">            well[&quot;r&quot;] : float </span>
<span class="sd">                radius of the well</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">        Wells can be a list of well dictionaries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Cleaning up well files: Starting&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s2">&quot;well_data&quot;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;well_data&quot;</span><span class="p">)</span>

    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;well_</span><span class="si">{0}</span><span class="s2">_line.inp&quot;</span><span class="p">,</span> <span class="s2">&quot;expand_well_</span><span class="si">{0}</span><span class="s2">.lgi&quot;</span><span class="p">,</span> \
        <span class="s2">&quot;well_</span><span class="si">{0}</span><span class="s2">_volume.inp&quot;</span><span class="p">,</span><span class="s2">&quot;expand_well_</span><span class="si">{0}</span><span class="s2">.out&quot;</span><span class="p">,</span>\
        <span class="s2">&quot;get_well_</span><span class="si">{0}</span><span class="s2">_zone.lgi&quot;</span><span class="p">,</span> <span class="s2">&quot;create_well_</span><span class="si">{0}</span><span class="s2">.out&quot;</span><span class="p">,</span>\
        <span class="s2">&quot;well_</span><span class="si">{0}</span><span class="s2">_intersect.inp&quot;</span><span class="p">,</span><span class="s2">&quot;create_well_</span><span class="si">{0}</span><span class="s2">.dump&quot;</span><span class="p">,</span>\
        <span class="s2">&quot;create_well_</span><span class="si">{0}</span><span class="s2">.log&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">wells</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span>
                        <span class="s2">&quot;well_data/&quot;</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;unable to mobe &quot;</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span> <span class="s1">&#39;warning&#39;</span><span class="p">)</span>
                <span class="k">pass</span>


    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">wells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span>
                                <span class="s2">&quot;well_data/&quot;</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">local_print_log</span><span class="p">(</span><span class="s2">&quot;unable to mobe &quot;</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]),</span> <span class="s1">&#39;warning&#39;</span><span class="p">)</span>
                    <span class="k">pass</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="s2">&quot;--&gt; Cleaning up well files: Complete&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="combine_well_boundary_zones"><a class="viewcode-back" href="../../../../pydfnWorks-well.html#pydfnworks.dfnGen.well_package.wells.combine_well_boundary_zones">[docs]</a><span class="k">def</span> <span class="nf">combine_well_boundary_zones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wells</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Processes zone files for particle tracking. All zone files are combined into allboundaries.zone </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        None </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If there is only 1 well, make a symbolic link</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;well_nodes.zone&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">number_of_wells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span>
        <span class="n">fall</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;well_nodes.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wells</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on well </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fzone</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">fzone</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">fall</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">number_of_wells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on well </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fzone</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">fzone</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">06d</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">fzone</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">fall</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">number_of_wells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on well </span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fzone</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;well_</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.zone&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">fzone</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">06d</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">fzone</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">fall</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">fall</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, LANL, LA-UR-17-22216.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>